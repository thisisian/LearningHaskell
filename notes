## Misc
'ys@(x:xs)' binds ys to (x:xs), usefully if we need to use both head/tail of list and the list in a function

## `seq`

'seq' function used to enforce strict evaluation
Forces evaluation of both arguments. Returns bottom if first argument is bottom, otherwise returns second argument.
Needs to be first thing in expression.
Need to use a 'let' give a expression a variable so it can be evaluated.

## Modules

Define a module and export functions `f1` and `f2` and all data contructors of type `T`:

```module (f1, f2, T(..))```

Import functions `f1` and `f2` from module `M`

import M (f1, f2)

## Types

An example, a `Just` type:

```
data Maybe a = Just a
             | Nothing
```

On the left side we have `Maybe` which is a *type constructor*
On the right we have `Just a` and `Nothing` which are *data constructors*.

-- `typeclass`

-- newtype
Easy way to wrap a type in another type:
`newtype MyType a = MyType a`

Faster than using `data` because value there is no need to unwrap the value.

The limitation is that you can't have data fields like regular type constructors.



-- Functor:

In Haskell, Functor is a typeclass:
```
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

It applies a function to all values of a type while retaining the type:
```
> fmap (+1) (Just 1)
Just 2
```

A functor as applied to functions is function composition:
fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)
This shows fmap now taking a function (a->b) and a function of (r->a) and gives a function (r->b).
We have a function takes r and return a. Then a function takes a and returns b. We have overall created a function that takes r and retruns b.

Functors must obey two laws:
1. fmap (id) (f a) = f a
2. fmap (a . b) (f a) = fmap a (fmap b (f a))

-- Applicative functor:

```
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```

`pure` - take a value and return the value inside a functor.
`<*>` - Take a functor with a function in it and a the functor with a in it and return the functor with b in it.

We can use like so:
```
> pure (+) <*> Just 5 <*> Just 9
Just 14
```

Can be used for sequencing IO actions:
```
> (++) <*> IO getStr <*> IO getStr
```
Asks for two lines of text and concatenates them.

Functions can be `Applicative`s. Their instance is as follows:
```
instance Applicative ((->) r) where
    pure x = (\_ -> x)
    f <*> g = \x -> f x (g x)
```

An example computation using functions as `Applicative`:

```
(+) <$> (+ 3) <*> (* 100) $ 5
=> (\_ -> (+)) <*> (+ 3) <*> (* 100) $ 5
=> \x -> (\_ -> (+)) x (+ 3 x) <*> (* 100) $ 5
=> \x -> (+) (+ 3 x) <*> (* 100) $ 5
=> \y -> (\x -> (+) (+ 3 x)) y (* 100 y) $ 5
=> (\x -> (+) (+ 3 x)) 5 (* 100 5)
=> (+) (+ 3 5) (* 100 5)
=> (+) 8 500
=> 508
```

-- Monad

`Monad` has the following interface:

```
class Monad m where
  (>>=)  :: m a -> (  a -> m b) -> m b
  (>>)   :: m a ->  m b         -> m b
  return ::   a                 -> m a
```